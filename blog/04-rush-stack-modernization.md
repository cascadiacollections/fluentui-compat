# Building Enterprise-Grade TypeScript Libraries with Rush Stack

## The Challenge of Modern Library Development

When we set out to build fluentui-compat, we knew from the start that this wasn't just about writing good code. We needed:

- **Robust TypeScript compilation** with strict mode and modern features
- **Automatic API documentation** that stays in sync with the code
- **Monorepo management** for multiple related packages
- **Comprehensive testing** across React 16, 17, 18, and 19
- **API surface management** to prevent accidental breaking changes
- **Professional developer experience** with modern tooling

This is where Microsoft's **Rush Stack** came in - a suite of tools designed specifically for building enterprise-grade TypeScript libraries.

## What is Rush Stack?

Rush Stack is a collection of build tools created and maintained by Microsoft, used internally for projects like Visual Studio Code, Azure DevOps, and... you guessed it... FluentUI itself.

The stack includes:

- **Rush**: Monorepo orchestrator and build system
- **Heft**: Modern build orchestrator with TypeScript, ESLint, and Jest integration
- **API Extractor**: Documentation generator and API surface manager
- **API Documenter**: Markdown documentation generator
- **Rushell**: Script executor for automation

## Before Rush Stack: The Pain Points

Before modernizing with Rush Stack, managing a TypeScript library meant juggling multiple tools:

```json
// Old approach - separate tools, complex configuration
{
  "scripts": {
    "build": "tsc",
    "lint": "eslint src --ext .ts,.tsx",
    "test": "jest",
    "docs": "typedoc src/index.ts"
  },
  "devDependencies": {
    "typescript": "^5.0.0",
    "eslint": "^8.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "jest": "^29.0.0",
    "ts-jest": "^29.0.0",
    "typedoc": "^0.25.0"
    // ... 20+ more packages
  }
}
```

Issues we faced:

1. **Configuration Drift**: tsconfig.json, .eslintrc, jest.config.js all needed manual synchronization
2. **Version Conflicts**: ESLint parsers had to match TypeScript versions
3. **Documentation Staleness**: Docs generated by TypeDoc often fell out of sync
4. **No API Governance**: Nothing prevented accidental breaking changes
5. **Complex Build Scripts**: Custom scripts to orchestrate build steps

## After Rush Stack: Integrated Excellence

With Rush Stack, the toolchain is integrated and standardized:

```json
// Modern approach - integrated toolchain
{
  "scripts": {
    "build": "heft build --clean",
    "test": "heft test --clean", 
    "lint": "heft lint"
  },
  "devDependencies": {
    "@rushstack/heft": "^0.66.0",
    "@microsoft/api-extractor": "^7.43.0"
  }
}
```

Everything is configured in one place and works together seamlessly.

## The Rush Monorepo Architecture

Rush manages our monorepo structure with precision:

```
fluentui-compat/
├── common/
│   ├── config/rush/         # Rush configuration
│   ├── scripts/             # Shared automation scripts
│   └── temp/                # Rush workspace (gitignored)
├── packages/
│   ├── fluentui-compat/
│   │   ├── src/             # Source code
│   │   ├── test/            # Tests
│   │   ├── package.json     # Package metadata
│   │   └── config/          # Build configuration
│   └── fluentui-compat-webpack-plugin/
│       ├── src/
│       ├── test/
│       └── package.json
└── rush.json                # Monorepo configuration
```

### Key Benefits of Rush

#### 1. Unified Dependency Management

Rush uses PNPM under the hood with a single lockfile for the entire monorepo:

```bash
# Install dependencies for all packages
rush update

# Rush ensures:
# - No phantom dependencies (packages can only import declared dependencies)
# - Reproducible installs across machines
# - Efficient disk usage with PNPM's content-addressable store
```

#### 2. Incremental Builds

Rush tracks dependencies between packages and only rebuilds what changed:

```bash
# Build only packages that changed since last build
rush build

# Build a specific package and its dependencies
rush build --to fluentui-compat

# Force clean rebuild of everything
rush rebuild
```

This saves tremendous time in CI/CD pipelines and local development.

#### 3. Change File Enforcement

One of Rush's killer features is **change files** - a way to track and document all changes:

```bash
# After making changes to a package
rush change

# Rush prompts:
# "What type of change is this?"
# - patch (bug fix)
# - minor (new feature)
# - major (breaking change)
#
# "Describe the change for the changelog"
```

Rush creates a change file that:
- Documents what changed and why
- Determines the next version number
- Generates changelog entries automatically
- **Enforced by CI** - PRs without change files cannot merge

This prevents accidental version conflicts and keeps changelogs accurate.

## Heft: The Modern Build Orchestrator

Heft is Rush's build orchestrator, replacing the need for multiple separate tools:

### config/heft.json

```json
{
  "$schema": "https://developer.microsoft.com/json-schemas/heft/v0/heft.schema.json",
  "extends": "@rushstack/heft-node-rig/profiles/library/config/heft.json",
  
  "phasesByName": {
    "build": {
      "tasksByName": {
        "typescript": {
          "taskPlugin": {
            "pluginPackage": "@rushstack/heft-typescript-plugin"
          }
        },
        "lint": {
          "taskPlugin": {
            "pluginPackage": "@rushstack/heft-lint-plugin"
          }
        }
      }
    },
    "test": {
      "tasksByName": {
        "jest": {
          "taskPlugin": {
            "pluginPackage": "@rushstack/heft-jest-plugin"
          }
        }
      }
    }
  }
}
```

### What Heft Provides

1. **TypeScript Compilation**
   - Incremental builds
   - Watch mode
   - Source maps
   - Declaration file generation

2. **ESLint Integration**
   - Runs alongside compilation
   - Uses the same TypeScript program (faster!)
   - Automatic type-aware linting

3. **Jest Integration**
   - TypeScript support via ts-jest
   - Coverage collection
   - Watch mode
   - Parallel test execution

4. **Asset Copying**
   - Copy static files to dist
   - Transform files during copy
   - Include/exclude patterns

All of this runs in a **single, optimized build pipeline** instead of separate commands.

## API Extractor: Documentation and Governance

API Extractor is the secret weapon for library maintainers. It generates three critical outputs:

### 1. API Report (.api.md)

A human-readable summary of your public API:

```markdown
## bundleIcon(FilledIcon, RegularIcon)

Creates a bundled icon component with memoization.

**Signature:**
```typescript
export declare function bundleIcon(
  FilledIcon: FluentIcon,
  RegularIcon: FluentIcon
): React.FC<BundleIconProps>;
```

**Parameters:**
- FilledIcon: FluentIcon - The filled icon variant
- RegularIcon: FluentIcon - The regular icon variant

**Returns:** React.FC<BundleIconProps>
```

This file is **checked into git**. If the API changes, the diff shows exactly what changed, making code review easier.

### 2. Type Definition Rollup (.d.ts)

A single declaration file with all public types:

```typescript
// dist/fluentui-compat.d.ts
export { bundleIcon } from './bundleIcon';
export { useAsync } from './useAsync';
export { useConst } from './useConst';
// ... etc
```

This is what consumers of your library import. API Extractor ensures it's clean, minimal, and doesn't leak internal types.

### 3. API JSON (.api.json)

Machine-readable API metadata for documentation generators, API diff tools, and other automation.

### api-extractor.json Configuration

```json
{
  "$schema": "https://developer.microsoft.com/json-schemas/api-extractor/v7/api-extractor.schema.json",
  
  "mainEntryPointFilePath": "<projectFolder>/lib/index.d.ts",
  
  "apiReport": {
    "enabled": true,
    "reportFolder": "<projectFolder>/temp/",
    "reportFileName": "fluentui-compat.api.md"
  },
  
  "dtsRollup": {
    "enabled": true,
    "untrimmedFilePath": "<projectFolder>/dist/fluentui-compat.d.ts"
  },
  
  "docModel": {
    "enabled": true,
    "apiJsonFilePath": "<projectFolder>/temp/fluentui-compat.api.json"
  }
}
```

## Real-World Impact

### Before Rush Stack

- **Build time**: ~45 seconds (full clean build)
- **CI pipeline**: 8-10 minutes for full test/build/deploy
- **Documentation**: Manually updated, often stale
- **Breaking changes**: Discovered by users in production
- **Developer onboarding**: 1-2 hours of setup

### After Rush Stack

- **Build time**: ~8 seconds (incremental), ~20 seconds (clean)
- **CI pipeline**: 3-4 minutes for full test/build/deploy
- **Documentation**: Auto-generated on every build
- **Breaking changes**: Caught in code review via API report diffs
- **Developer onboarding**: 10 minutes with DevContainer

## The Modernization Process

Here's how we migrated fluentui-compat to Rush Stack:

### Step 1: Initialize Rush

```bash
# Install Rush globally
npm install -g @microsoft/rush

# Initialize Rush in the repository
rush init

# This creates:
# - rush.json (monorepo config)
# - common/config/ (Rush configuration)
# - .gitignore updates
```

### Step 2: Configure Packages

Update `rush.json` with our packages:

```json
{
  "projects": [
    {
      "packageName": "@cascadiacollections/fluentui-compat",
      "projectFolder": "packages/fluentui-compat",
      "reviewCategory": "production"
    },
    {
      "packageName": "@cascadiacollections/fluentui-compat-webpack-plugin",
      "projectFolder": "packages/fluentui-compat-webpack-plugin",
      "reviewCategory": "production"
    }
  ]
}
```

### Step 3: Add Heft Configuration

Create `config/heft.json` in each package:

```json
{
  "$schema": "https://developer.microsoft.com/json-schemas/heft/v0/heft.schema.json",
  "extends": "@rushstack/heft-node-rig/profiles/library/config/heft.json"
}
```

### Step 4: Configure API Extractor

Create `api-extractor.json` in each package for documentation generation.

### Step 5: Update Scripts

Simplify package.json scripts:

```json
{
  "scripts": {
    "build": "heft build --clean",
    "test": "heft test",
    "lint": "heft lint"
  }
}
```

### Step 6: Set Up CI/CD

Update GitHub Actions to use Rush commands:

```yaml
- name: Install dependencies
  run: rush update

- name: Build packages
  run: rush build --verbose

- name: Test packages  
  run: rush test --verbose

- name: Verify change files
  run: rush change --verify
```

## DevContainer Integration

To make onboarding even easier, we integrated everything into a DevContainer:

```json
// .devcontainer/devcontainer.json
{
  "name": "FluentUI Compat",
  "image": "mcr.microsoft.com/devcontainers/typescript-node:22",
  
  "postCreateCommand": "npm install -g @microsoft/rush && rush update",
  
  "features": {
    "ghcr.io/devcontainers/features/github-cli:1": {}
  },
  
  "customizations": {
    "vscode": {
      "extensions": [
        "dbaeumer.vscode-eslint",
        "ms-vscode.vscode-typescript-next",
        "GitHub.copilot"
      ]
    }
  }
}
```

New contributors can:
1. Open the repo in VS Code
2. Click "Reopen in Container"
3. Wait 2 minutes for setup
4. Start coding immediately

## Lessons Learned

### What Worked Great

1. **Change Files**: Forced discipline around versioning and changelogs
2. **API Reports**: Made code reviews much easier - API changes are obvious
3. **Incremental Builds**: Massive time savings in development and CI
4. **Monorepo Structure**: Natural organization for related packages
5. **DevContainer**: Eliminated "works on my machine" issues

### Challenges

1. **Learning Curve**: Rush has many concepts to learn initially
2. **Documentation**: Some Rush Stack docs are sparse or outdated
3. **Tooling Integration**: Some IDEs don't understand Rush's workspace structure
4. **Debugging**: Build issues can be harder to debug than simple npm scripts

### Solutions

1. **Comprehensive README**: We wrote detailed docs for contributors
2. **Example Projects**: Created example configurations for common scenarios
3. **VS Code Tasks**: Added tasks.json for common Rush commands
4. **Copilot Integration**: AI coding assistants help navigate Rush commands

## Best Practices

### 1. Use Change Files Religiously

```bash
# After every package change
rush change

# CI should enforce this
rush change --verify
```

### 2. Keep API Reports in Git

```gitignore
# Don't ignore these!
# temp/*.api.md should be tracked
```

API reports in version control make code review much more effective.

### 3. Leverage Rush Rigs

Rush "rigs" are shareable configuration packages:

```json
{
  "extends": "@rushstack/heft-node-rig/profiles/library/config/heft.json"
}
```

This reduces duplication and standardizes configuration across packages.

### 4. Use Rush Scripts for Automation

```json
// common/config/rush/command-line.json
{
  "commands": [
    {
      "name": "docs",
      "commandKind": "bulk",
      "summary": "Generate documentation for all packages",
      "enableParallelism": true
    }
  ]
}
```

### 5. Document Everything

Create comprehensive README files:
- Root README: Project overview and getting started
- Package READMEs: API documentation and examples
- MONOREPO.md: Rush-specific instructions
- .devcontainer/README.md: DevContainer usage guide

## The Future of fluentui-compat

With Rush Stack as our foundation, we're set up for:

- **Additional packages**: Easy to add new utilities to the monorepo
- **Plugin architecture**: Support for community-contributed plugins
- **Documentation site**: Auto-generated docs published to GitHub Pages
- **Automated releases**: Rush handles versioning and npm publishing
- **Community contributions**: Clear processes make contributing easier

## Try It Yourself

Want to modernize your own TypeScript library with Rush Stack?

```bash
# Install Rush
npm install -g @microsoft/rush

# Initialize in your repo
rush init

# Follow the prompts to configure your packages
```

Check out the [Rush Stack documentation](https://rushstack.io/) and our [implementation in fluentui-compat](https://github.com/cascadiacollections/fluentui-compat) for examples.

## What's Next?

In our final post, we'll explore the **fluentui-compat-webpack-plugin**:
- How it automatically rewrites imports from @fluentui to fluentui-compat
- Webpack 4 and 5 support
- Babel-based AST transformation
- Configuration examples for React, Next.js, and Create React App

## Resources

- **Rush Stack**: https://rushstack.io/
- **API Extractor**: https://api-extractor.com/
- **Heft**: https://rushstack.io/pages/heft/overview/
- **fluentui-compat**: https://github.com/cascadiacollections/fluentui-compat
- **API Documentation**: https://cascadiacollections.github.io/fluentui-compat/

---

*Have you used Rush Stack in your projects? Share your experiences in the comments!*
